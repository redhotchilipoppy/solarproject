# -*- coding: utf-8 -*-
"""
Created on Wed Jan  3 08:03:37 2024

@author: Axel
This script will take our previously trained PV forecast model and create a forecast.
The forecast is presented as a plot with prediction intervals.
The forecast is also saved to csv file.
The forecast is from the current day and streches a user defined amount of days into the future.
"""
print("Starting script Build Solar RF Model...")
print(" ")
#%% 0. Imports 
# Import all required packages
# If you are using Anaconda most of these packages should be pre-installed.
# For the packages not pre-installed, you can install them by running the lines below:
# pip install openmeteo-requests
# pip install requests-cache retry-requests numpy pandas
# pip install quantile-forest

# Data import from open-meteo.com
import openmeteo_requests               
import requests_cache
from retry_requests import retry

# Data management and visualization
import pandas as pd
import numpy as np
import datetime
import pickle
import matplotlib
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

# Machine Learning
import sklearn

# Print version info
print("Version info:")
print('pandas: %s' % pd.__version__)
print('numpy: %s' % np.__version__)
print('sklearn: %s' % sklearn.__version__)
print(" ")


#%% 1. User Inputs
# These inputs may be changed by the user
model_file_name = "YOUR MODEL.pkl"    # This is the name of the file generated by the script "Build_solar_RF_model.py" (must be located in same folder)
horizon = 5                                                    # Forecast horizon in days, limit is 16 days.
                                                               # Note that the further we look into the future, the less accurate the weather forecast is likely to be
PV_capacity = 15                                               # The maximum capacity of your PV installation in kW, only used for plotting.

#%% 2. Read Model
# Read in the model
f_model = open(model_file_name, 'rb')               # Opens the file
model_dict = pickle.load(f_model)                   # Reads the dictionary from the file
f_model.close()                                     # closes the file again

#%% 3. Fetch weather forecast

# Setup the Open-Meteo API client with cache and retry on error
cache_session = requests_cache.CachedSession('.cache', expire_after = -1)
retry_session = retry(cache_session, retries = 5, backoff_factor = 0.2)
openmeteo = openmeteo_requests.Client(session = retry_session)

# Make sure all required weather variables are listed here
url = "https://api.open-meteo.com/v1/forecast"

# Calcualte start and end date
start_date = datetime.datetime.now()
end_date = start_date + datetime.timedelta(days=horizon)
sdate_str = str(start_date)[0:10]                       # First date in file as string (yyyy-mm-dd)
edate_str = str(end_date)[0:10]                         # Last date in file as string (yyyy-mm-dd)

# Use the same parameters as was used for training the model.
params = {
	"latitude": model_dict['API Request Params']['latitude'],
	"longitude": model_dict['API Request Params']['longitude'],
	"hourly": model_dict['API Request Params']['hourly'],
    "start_date": sdate_str,
    "end_date": edate_str,
}
responses = openmeteo.weather_api(url, params=params)

# Process & print request info.
response = responses[0]
print("Request info:")
print(f"Coordinates {response.Latitude()}°E {response.Longitude()}°N")
print(f"Elevation {response.Elevation()} m asl")
print(f"Timezone {response.Timezone()} {response.TimezoneAbbreviation()}")
print(f"Timezone difference to GMT+0 {response.UtcOffsetSeconds()} s")
#print(f"From: " + sdate_str + " To: " + edate_str)
print(" ")

# Process hourly data. The order of variables needs to be the same as requested.
hourly = response.Hourly()                                  # API Response
hourly_data = {"date": pd.date_range(                       # Dictionary that we add the API respnse to
	start = pd.to_datetime(hourly.Time(), unit = "s"),
	end = pd.to_datetime(hourly.TimeEnd(), unit = "s"),
	freq = pd.Timedelta(seconds = hourly.Interval()),
	inclusive = "left"
)}

# We iterate through the variables and add the API response data to our dictionary
print("Adding variables to dataframe...")
index_variable = 0
for variable in params['hourly']:
    hourly_data[variable] = hourly.Variables(index_variable).ValuesAsNumpy()    # Add the variable to dataframe
    print("Added " + variable)
    index_variable += 1                                                         # Increment counter
    
print(" ")
# Create dataframe
weather_data = pd.DataFrame(data = hourly_data)    
weather_data = weather_data.set_index('date')    # Set index to be dates

#%% 4. Data manipulation & encoding
# Create a new dataframe to hold all data, also encode new features.

# Create a main dataframe that holds all data
main_df = weather_data.copy()

for index, row in main_df.iterrows():
    main_df.loc[index,'month'] = index.month
    main_df.loc[index,'day'] = index.day
    main_df.loc[index,'hour'] = index.hour
    main_df.loc[index,'sine month'] = np.sin((index.month - 1)*np.pi/11)
    main_df.loc[index,'cos month'] = np.cos((index.month - 1)*np.pi/11)
    main_df.loc[index,'sine hour'] = np.sin((index.month - 1)*np.pi/23)
    main_df.loc[index,'cos hour'] = np.cos((index.month - 1)*np.pi/23)

# Index to keep track of which hours the sun is up for.        
Sun_index = main_df[main_df['is_day'] == 1].index        

# Create a new dataframe with only relevant data, this will be used for statistical 
sun_is_up_data = main_df.copy()                                 # Create copy
sun_is_up_data = sun_is_up_data.loc[Sun_index]                  # Only include rows when the sun is up
sun_is_up_data = sun_is_up_data[model_dict['Input features']]   # Only include columns needed for model


#%% 5. Make Predictions
print("Making predictions...")
# Create dataframe to hold predictions and initialize with 0.
predictions = pd.DataFrame(0, index = weather_data.index, columns = ['Main Forecast', 'Lower Bound', 'Upper Bound'])
predictions['Date'] = predictions.index.tolist()             # Make dates also to a column for easier plotting

# Make predictions
predictions.loc[Sun_index,'Main Forecast'] = model_dict['Random Forest Model'].predict(sun_is_up_data)
predictions.loc[Sun_index,['Lower Bound', 'Upper Bound']] = model_dict['Random Forest Quantile Model'].predict(sun_is_up_data, [0.1, 0.9])
print(" ")
#%% 6. Make Plot

# Plotting
plt.style.use('_mpl-gallery')                   # Set plot style
matplotlib.rc('font', **{'size'   : 20})        # Change font size
fig, ax = plt.subplots()                        # Create plot
fig.set_size_inches(18.5, 10.5, forward=True)   # Set figure size
fig.set_dpi(100)                                # Set resolution
ax.fill_between(predictions['Date'], predictions['Lower Bound'], predictions['Upper Bound'], alpha=.5, linewidth=0) # Plot prediction interval
ax.plot(predictions['Date'], predictions['Main Forecast'], linewidth=4, color='black')                              # Plot main forecast

# Calculate x-ticks
step_length = int(predictions.shape[0]/42)
ax.set(ylim = [0,PV_capacity*1.05], xticks = predictions['Date'].iloc[::step_length])
ax.xaxis.set_major_formatter(mdates.DateFormatter('%m-%d %H:%M'))
plt.ylabel('Solar power [kW]')
plt.xticks(rotation=90)
plt.legend(['Prediction Interval (10 - 90%)', 'Main Forecast'])
plt.title('Solar Power Forecast from ' + sdate_str + ' to ' + edate_str)
plt.show()

#%% 7. Save Forecast
# Save the forecast result together with the weather data

datecreated = datetime.datetime.now().strftime("%Y-%m-%dT%H:%M:%S") # When the file was created
filename = "Solar Forecast_from_" + sdate_str + " to " + edate_str + " created " + datecreated + "_.csv"
filename = filename.replace(":","-") # Replace ":" as we cant have this symbol in filenames...

# Add the predictions to the main dataframe and save the whole thing
for column in ['Main Forecast', 'Lower Bound', 'Upper Bound']:
    main_df[column] = predictions[column]

main_df.to_csv(filename)
print("Done! Saved to: " + filename)